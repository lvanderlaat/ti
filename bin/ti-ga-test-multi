#!/usr/bin/env python


"""
"""


# Python Standard Library
import argparse
import os
import time

# Other dependencies
import numpy as np
import pandas as pd
import ti
import xarray as xr

from pymoo.algorithms.soo.nonconvex.ga import GA
from pymoo.operators.crossover.sbx import SBX
from pymoo.operators.mutation.pm import PM
from pymoo.optimize import minimize
from pymoo.termination import get_termination
from scipy import signal
from scipy.fft import rfft
from scipy.ndimage import gaussian_filter


# Local files

__author__ = 'Leonardo van der Laat'
__email__ = 'laat@umich.edu'


def parse_args():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument('configfile', help='Configuration file path')
    parser.add_argument('station', help='Station')
    return parser.parse_args()


def main():
    # Load configuration
    args = parse_args()
    c = ti.config.read(args.configfile)

    # Output
    folderpath = ti.utils.create_folder(
        c.io.output_dir, f'GA_MULTI_{args.station}', c.io.overwrite
    )
    ti.utils.write_conf(c, folderpath)

    ti.parameters.write_latex(c, folderpath)

    # Load channels
    channels = pd.read_csv(c.source.channels_csv, comment='/')
    channels = channels[channels.station == args.station]
    channels.to_csv(os.path.join(folderpath, 'channels.csv'), index=False)

    # Load observations
    obs = xr.open_dataarray(os.path.join(c.optimize.obs_folder, 'data.nc'))

    # Filter depending to channels csv file
    obs = obs.where(obs.station.isin(channels.station), drop=True)
    obs = obs.sel(t=c.test.time, method='nearest')

    b, a = signal.butter(c.optimize.filter[0], c.optimize.filter[1], 'low')

    # Algorithm
    algorithm = GA(
        pop_size=c.moo.pop_size,
        n_offsprings=c.moo.n_offsprings,
        crossover=SBX(**c.moo.sbx),
        mutation=PM(**c.moo.pm),
        eliminate_duplicate=c.moo.eliminate_duplicate
    )

    # Termination criteria
    termination = get_termination('n_gen', c.moo.n_gen)

    # Model parameters
    param = dict(c.model)
    keys = [key for key, value in param.items() if type(value) is list]
    param['xr'] = channels.x.tolist()
    param['yr'] = channels.y.tolist()
    param['zr'] = channels.z.tolist()

    Sx_obs = obs.transpose('station', 'f').values[0]

    df, df_min, df_max = ti.peak.extrema(Sx_obs)
    df_max.sort_values(by='a', inplace=True, ascending=False)
    df_max = df_max[:c.multi.n_peaks]

    t0 = time.time()
    fn, opt = [], []
    for i, row in df_max.iterrows():
        ic = df.idx[i]
        il = df.idx[i - 1]
        ir = df.idx[i + 1]

        _fn = obs.f.values[ic]

        fnat_range = [_fn - c.multi.delta, _fn + c.multi.delta]

        # Peak prominence
        perc_diff = 100 * np.abs(
            Sx_obs[ic] - max(Sx_obs[il], Sx_obs[ir])
        )/Sx_obs[ic]

        if perc_diff < 10:
            continue

        y = Sx_obs.copy()
        mask = np.ones(len(y), np.bool)
        mask[il:ir] = False
        y[mask] = 0

        problem = ti.multichromatic.Problem(
            Sx_obs=y, f=obs.f.values, param=param, keys=keys,
            sigma=c.multi.sigma, fnat_range=fnat_range,
            perc_diff_max=c.multi.perc_diff_max
        )

        result = minimize(
            problem, algorithm, termination, seed=1, save_history=False,
            verbose=True,
        )
        try:
            opt.append(ti.multichromatic.var_to_dict(param, keys, result.X))
            fn.append(_fn)
        except Exception as e:
            print(e)
            continue

    df = pd.DataFrame(opt)
    df['fn'] = fn
    df.sort_values(by='fn', inplace=True)
    df.to_csv(os.path.join(folderpath, 'param.csv'))

    V = []
    for i, _opt in enumerate(opt):
        _, _, _V = ti.synth.synthetize_wave(_opt)
        V.append(_V[0])
    V = np.array(V).sum(axis=0)
    Sx_syn = np.abs(rfft(V))
    Sx_syn = gaussian_filter(Sx_syn, sigma=0.5)

    fig = ti.plot.optimized_spectrum_multi(
        obs.f.values, Sx_obs, Sx_syn, fn, c.multi.delta
    )
    fig.savefig(os.path.join(folderpath, 'opt_spec.png'), dpi=250)

    t1 = time.time()

    print(f'Optimization time: {t1-t0:.1f} s')
    return


if __name__ == '__main__':
    main()
